<!DOCTYPE html>
<html>
  <body>
    <div id="root"></div>
  </body>
  <script src="https://unpkg.com/react@18.2.0/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="text/babel">
    const root = ReactDOM.createRoot(document.getElementById("root"));

    const Btn = ({ text, onClick }) => {
      return (
        <button
          onClick={onClick}
          style={{
            backgroundColor: "teal",
            color: "white",
            padding: "10px 20px",
            border: "0",
            borderRadius: 10,
          }}
        >
          {text}
        </button>
      );
    };

    // prop 변경되지 않는다면 rerender를 하지 말라고 하자
    // 함수가 실행되기 전에 이전 props vs 새 props 비교
    const MemoBtn = React.memo(Btn);

    // React.memo = "props 안 바뀌면 함수 실행 스킵하는 도구";

    // 언제 써요?
    // - 컴포넌트가 복잡할 때
    // - 리스트 아이템
    // - 부모가 자주 재렌더링되는데 자식은 안 바뀔 때

    // 언제 안 써요?
    // - 간단한 컴포넌트
    // - props가 항상 바뀌는 경우
    // - 성능 문제가 없을 때

    // const Btn = React.memo(({ text, onClick }) => {
    //   console.log(`${text} 렌더링!`);
    //   return <button onClick={onClick}>{text}</button>;
    // });

    const App = () => {
      const [val, setVal] = React.useState("Save Changes");
      const changeVal = () => setVal("Revert Changes");

      // memo 아닐 경우..
      // App 함수 재실행 -> Btn 재실행
      // 가상 DOM 생성 vs 이전 가상 DOM -> 실제 DOM 업데이트
      return (
        <div>
          <Btn text={val} onClick={changeVal} />
          <Btn text="Continue" />
        </div>
      );
    };

    root.render(<App />);
  </script>
</html>
